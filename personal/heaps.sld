(define-library (personal heaps)
  (import (scheme base))
  (export root left right make-heap no-left? no-right? merge biggest remove-top list->heap heapsort)
  (begin
    (define (root heap)
      (car heap))
    (define (left heap)
      (cadr heap))
    (define (right heap)
      (cddr heap))
    (define (make-heap val left right)
      (cons val
            (cons left right)))
    (define (no-left? heap)
      (null? (left heap)))
    (define (no-right? heap)
      (null? (right heap)))
    (define (heap? heap)
      (pair? heap))
    (define (merge heap-a heap-b)
      (cond ((not (heap? heap-a))
             heap-b)
            ((not (heap? heap-b))
             heap-a)
            (else
      (let ((bigger (if (> (root heap-a) (root heap-b))
                        heap-a
                        heap-b))
            (smaller (if (> (root heap-a) (root heap-b))
                         heap-b
                         heap-a)))
        (cond ((and (no-left? bigger) (no-left? smaller))
               (make-heap (root bigger) smaller '()))
              ((no-right? bigger)
               (make-heap (root bigger)
                          smaller
                          (left bigger)))
              (else
               (make-heap (root bigger)
                          (merge smaller (right bigger))
                          (left bigger))))))))
    (define (biggest heap)
      (car heap))
    (define (remove-top heap)
      (merge (left heap) (right heap)))
    (define (list->heap list)
      (let kernel ((lst (cdr list))
                   (heap (make-heap (car list) '() '())))
        (if (null? lst)
            heap
            (kernel (cdr lst)
                    (merge heap (make-heap (car lst) '() '()))))))
    (define (heapsort list)
      (let kernel ((heap (list->heap list))
                   (return-list '()))
        (if (not (null? heap))
            (kernel (remove-top heap) (cons (biggest heap) return-list))
            return-list)))))
